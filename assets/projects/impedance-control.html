<div class="modal-section overview-section">
    <div class="overview-text">
        <h3 class="modal-section-title">Overview</h3>
        <p>Impedance control is central to enabling safe and compliant robot interaction. I like to think of it as shaping a robot's behavior through a virtual spring-mass-damper (MSD) system, helping it respond naturally to unexpected forces.</p>
        <p>This approach is especially important for robots that work closely with people, such as exoskeletons and collaborative arms. The Harmony SHR exoskeleton pictured here is a great example of a system that benefits from impedance-based control.</p>
    </div>
    <div class="overview-image">
        <img src="assets/images/project_images/impedance-control/harmony-impedance.gif" alt="Harmony robot in impedance control mode" loading="lazy">
    </div>
</div>

<div class="modal-section">
    <h3 class="modal-section-title">Control Formulation</h3>
    <div class="modal-section overview-section">
        <div class="overview-image">
            <img src="assets/images/project_images/impedance-control/formulation.png" alt="Control formulation in task space and joint space" loading="lazy">
        </div>
        <div class="overview-text">
            <p>A standard impedance objective is to enforce a dynamic relationship of the form: </p>
            <div class="impedance-equation" role="img" aria-label="M times x double dot plus B times velocity error plus K times position error equals the external force.">
                <div class="impedance-equation-row">
                    <span class="impedance-term">
                        <span class="impedance-symbol">M</span>
                        <span class="impedance-operator">&times;</span>
                        <span class="impedance-variable">x&#776;</span>
                    </span>
                    <span class="impedance-operator">+</span>
                    <span class="impedance-term">
                        <span class="impedance-symbol">B</span>
                        <span class="impedance-operator">&times;</span>
                        <span class="impedance-variable">(x&#775; - x&#775;<sub>d</sub>)</span>
                    </span>
                    <span class="impedance-operator">+</span>
                    <span class="impedance-term">
                        <span class="impedance-symbol">K</span>
                        <span class="impedance-operator">&times;</span>
                        <span class="impedance-variable">(x - x<sub>d</sub>)</span>
                    </span>
                    <span class="impedance-operator">=</span>
                    <span class="impedance-term">
                        <span class="impedance-symbol">F<sub>ext</sub></span>
                    </span>
                </div>
                <dl class="impedance-legend">
                    <div class="legend-item">
                        <dt>M, B, K</dt>
                        <dd>virtual mass, damping, and stiffness gains</dd>
                    </div>
                    <div class="legend-item">
                        <dt>x&#776;, x&#775;</dt>
                        <dd>task-space acceleration and velocity (with desired velocity x&#775;<sub>d</sub>)</dd>
                    </div>
                    <div class="legend-item">
                        <dt>(x - x<sub>d</sub>)</dt>
                        <dd>position error relative to the desired pose</dd>
                    </div>
                    <div class="legend-item">
                        <dt>x → q</dt>
                        <dd>swap task-space pose for joint coordinates to run the same law in joint space</dd>
                    </div>
                </dl>
            </div>
            <p>To achieve this, the controller first compensates gravity and other predictable torques so that only the interaction force remains. This interaction force becomes the input to the virtual MSD model, rather than directly moving the robot. The result is force-driven motion that feels compliant but controlled.</p>
            <p>Internally, the controller relies on the Recursive Newton-Euler (RNE) algorithm to evaluate the robot's inverse dynamics. RNE provides fast estimates of gravity, Coriolis, and inertial torques, allowing the controller to cancel these “bias forces” before applying the impedance law. This separation is what lets the robot respond as a pure MSD system to external interaction forces.</p>
        </div>
    </div>
</div>

<div class="modal-section">
    <h3 class="modal-section-title">Trajectory Following</h3>
    <div class="modal-section overview-section">
        <div class="overview-text">
            <p>In this project, I experimented with impedance control in both joint space and task space. Task-space control quickly became the most intuitive to work with.</p>
            <p>It lets the end-effector follow a desired trajectory while still yielding to external forces, making the behavior feel smooth rather than rigid. Disturbances are rejected gracefully, and the robot stays responsive.</p>
            <p>This setup also allows stiff tracking in task space while keeping the null space compliant, enabling more natural and adaptable motion.</p>
        </div>
        <div class="overview-image">
            <img src="assets/images/project_images/impedance-control/trajectory-following-ns.gif" alt="EE Trajectory Following with impedance control" loading="lazy">
        </div>
    </div>
</div>

<div class="modal-section">
    <h3 class="modal-section-title">Bilateral Teleoperation</h3>
    <div class="modal-section overview-section">
        <div class="overview-image">
            <img src="assets/images/project_images/impedance-control/bilateral-teleop.gif" alt="Bilateral teleoperation" loading="lazy">
        </div>
        <div class="overview-text">
            <p>Bilateral teleoperation is a natural application of impedance control. A master device guides a follower robot, and the operator feels the forces the follower encounters.</p>
            <p>Using a joint-space impedance proxy, I was able to create a simple yet effective haptic loop. When the master and follower robots share similar kinematics, this method works surprisingly well and feels intuitive to operate.</p>
            <p>This setup allowed me to prototype haptic behaviors before exploring more challenging robot pairings.</p>
        </div>
    </div>
</div> 

<div class="modal-section">
    <h3 class="modal-section-title">Bilateral Teleop with Different Robots</h3>
    <div class="modal-section overview-section">
        <div class="overview-text">
            <p>When the master and follower robots have different kinematics or degrees of freedom, the joint-space impedance proxy starts to break down.</p>
            <p>To handle these mismatches, I switched to task-space impedance control, with two robots tracking a shared virtual proxy. This formulation is more flexible and lets forces and motions be mapped consistently between very different robots.</p>
            <p>It also allows independent stiffness tuning along each task-space dimension, which becomes useful when coordinating robots with different workspaces or capabilities.</p>
        </div>
        <div class="overview-image">
            <img src="assets/images/project_images/impedance-control/bilateral_diff_kin.gif" alt="Bilateral teleop with different robots" loading="lazy">
        </div>
    </div>
</div>


<div class="modal-section"> 
    <h3 class="modal-section-title">Simulation vs. Reality</h3> 
    <div class="modal-section overview-section"> 
        <div class="overview-image"> 
            <img src="assets/images/project_images/impedance-control/reality.png" alt="Workarounds irl" loading="lazy"> 
        </div> 
        <div class="overview-text"> 
            <p>Simulation makes impedance control look easy: joints are perfectly backdrivable, frictionless, and every commanded torque turns into clean motion.</p> 
            <p>Real hardware is far less ideal. Gear transmissions add friction, backlash, and large reflected inertia, so the small interaction forces impedance control depends on often vanish inside the drivetrain. That's why a controller that feels smooth in simulation can feel stiff or “numb” on a physical robot - the virtual MSD behavior is still computed, but the mechanics mask it.</p> 
            <p>Modern approaches tackle this from several angles. Quasi-direct-drive (QDD) actuators cut gear ratios to improve backdrivability and torque transparency. High-end robots pair joint torque sensors with high-rate inner loops to cancel friction and nonlinearities. Robots without torque sensing rely on end-effector F/T sensors or admittance control, which recreates compliance through stiff position control rather than true torque transparency.</p> 
        </div> 
    </div> 
</div>


<div class="modal-section">
    <h3 class="modal-section-title">Aside: Admittance Control</h3> 
    <div class="modal-section overview-section"> 
        <div class="overview-text"> 
            <p>To demonstrate some common workarounds for real hardware, I also implemented a basic admittance controller. Admittance control uses position control to simulate a virtual MSD system, rather than relying on torque transparency.</p>
            <p>In this setup, the external force is measured at the end-effector using a force/torque sensor. The measured wrench now scales with task space end-effector twist, which is then tracked using a high-gain position controller.</p>
            <p>This approach helps to generate compliant task space behaviors even when the robot's joints are not backdrivable, enabling safe and intuitive human-robot interaction.</p>
        </div>
        <div class="overview-image">
            <img src="assets/images/project_images/impedance-control/xarm_admittance.gif" alt="Admittance control demo" loading="lazy">
        </div>
    </div>
</div>